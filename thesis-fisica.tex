\chapter{Progettazione fisica}
\label{physical}

La fase di progettazione logica (Sezione \ref{logical}) produce uno schema logico, formalizzato nel modello relazionale, che descrive l'insieme di tabelle e di vincoli su di esse che contengono i dati di interesse.
Questo schema è interrogabile, ovvero è possibile formulare delle interrogazioni (anche dette \emph{query} o richieste) sulla base di dati; le interrogazioni si formulano attraverso linguaggi formali specifici per il modello relazionale come algebra relazionale e calcolo relazionale.

Il linguaggio SQL (\emph{Structured Query Language}) è un linguaggio di interrogazione per basi di dati relazionali \cite{Sil11}, affermatosi come standard \emph{de facto} (grazie alle numerose implementazioni nei sistemi distribuiti commercialmente) e anche \emph{de iure}\footnote{
Il primo standard ANSI e ISO per il linguaggio SQL è del 1986 (SQL-86) \cite{Sil11}. Successivamente sono stati pubblicati diversi aggiornamenti fino alla versione attuale, SQL:2023 (ISO/IEC 9075:2023).
}.
SQL è composto di diverse parti: è possibile esprimere sia la definizione delle tabelle (DDL, \emph{Data Definition Language}) sia le operazioni di inserimento, modifica, cancellazione e interrogazione (DML, \emph{Data Manipulation Language}), insieme anche ai vincoli di integrità e ai privilegi degli utenti che possono accedere alla base di dati.

In questo capitolo costruiamo fisicamente la base di dati progettata nei capitoli precedenti attraverso diversi \emph{script} in linguaggio SQL.
Il DBMS che utilizziamo è PostgreSQL, uno tra i più diffusi DBMS relazionali.

\section{Definizione dei domini}
\label{physicaldomains}

Per quanto riguarda i tipi di dato semplici, in PostgreSQL il tipo corrispondente alle stringhe è \sql{varchar} (\emph{variable character}) e il tipo corrispondente ai numeri rappresentati in virgola mobile è \sql{real}.

Alcune tabelle dello schema logico presentano attributi con vincoli sul dominio o con un insieme finito di valori possibili.
In SQL è possibile definire domini, utilizzabili poi allo stesso modo di quelli predefiniti del linguaggio, che sintetizzano i vincoli da imporre ed evitano ripetizioni e quindi possibili inconsistenze.

I tipi enumerazione, ovvero che possono assumere un insieme finito e contenuto di valori, si implementano come interi (a cui però serve poi aggiungere una funzione di conversione a livello più alto per tradurre il numero nel valore semantico corrispondente) oppure come stringa (\sql{varchar}) su cui viene imposto il vincolo di appartenenza all'insieme di valori del dominio; per la base di dati che stiamo costruendo scegliamo la seconda implementazione.

Elenchiamo di seguito i domini definiti per lo schema relazionale della base di dati (\lstlistingname{} \ref{pdom})\footnote{
  Tutti i frammenti di codice mostrati nei listati di questa tesi sono disponibili anche nella \emph{repository} al link\linebreak \url{https://github.com/andr3wsm/bach/tree/main/sql-scripts}.
}.

\begin{itemize}
\item Nella tabella \tab{paziente} si utilizza come identificatore il codice fiscale italiano, ovvero una stringa alfanumerica di 16 caratteri.
\item Nella tabella \tab{gravidanza} l'attributo \at{pma\_tipo} contiene l'informazione relativa al tipo di procreazione medicalmente assistita, che può avere valore \val{iui}, \val{fivet} o \val{icsi}.
\item Nella tabella \tab{visita} l'attributo \at{categoria\_visita}, relativo al tipo di visita, può avere valore \val{primo\_trimestre}, \val{secondo\_trimestre}, \val{biometrica} o \val{altro\_tipo}. Nella stessa tabella, l'attributo \at{stato\_crescita} può avere valore \val{regolare}, \val{fgr} o \val{sga}.
\item Per la tabella \tab{parto} è richiesta la dichiarazione di diversi domini. L'attributo \at{tipo\_parto} indica il tipo di parto e può avere valore \val{cesareo\_programmato} o \val{parto\_con\_travaglio}. L'attributo \at{tipo\_secondamento} può avere valore \val{attivo}, \val{strumentale}, \val{manuale} o \val{scovolamento}. L'attributo \at{robson} può avere valore \val{1}, \val{2a}, \val{2b}, \val{3}, \val{4a}, \val{4b}, \val{5.1}, \val{5.2}, \val{6}, \val{7}, \val{8}, \val{9} o \val{10}. L'attributo \at{analgesia} può avere valore \val{spinale}, \val{peridurale}, \val{spinale\_peridurale}, \val{calinox}.
\item Nella tabella \tab{parto\_con\_cesareo} l'attributo \at{sottotipo\_parto} può avere valore uguale a \val{naturale}, \val{operativo}, \val{cesareo}, \val{naturale\_operativo}, \val{naturale\_cesareo}, \val{operativo\_cesareo}, mentre l'attributo \at{lacerazioni} può avere valore \val{episiotomia}, \val{tracheloraffia}, \val{nessuna}, \val{grado\_1}, \val{grado\_2}, \val{grado\_3}, \val{grado\_4}, \val{altro}.
\item Nella tabella \tab{induzione} l'attributo \at{metodo\_induzione} può avere valore \val{amnioressi}, \val{cook},\linebreak \val{cook\_misoprostolo}, \val{cook\_ossitocina}, \val{dilapan}, \val{dilapan\_misoprostolo}, \val{dilapan\_ossitocina}, \val{misoprostolo}, \val{propess} o \val{propidil}.
\end{itemize}

\begin{lstlisting}[float,caption={Definizione dei domini.},label=pdom]
-- Dominio codice_fiscale per persona
create domain codice_fiscale as char(16);
-- Dominio pma_tipo_enum per +gravidanza
create domain pma_tipo_enum as varchar
check (value in ('iui','fivet','icsi'));
-- Dominio categoria_visita_enum per visita
create domain categoria_visita_enum as varchar
check (value in ('primo_trimestre','secondo_trimestre','biometrica',
  'altro_tipo'));
-- Dominio stato_crescita_enum per visita
create domain stato_crescita_enum as varchar
check (value in ('regolare','fgr','sga'));
-- Dominio tipo_parto_enum per parto
create domain tipo_parto_enum as varchar
check (value in ('cesareo_programmato','parto_con_travaglio'));
-- Dominio tipo_secondamento_enum per parto
create domain tipo_secondamento_enum as varchar
check (value in ('attivo','strumentale','manuale','scovolamento'));
-- Dominio robson_enum per parto
create domain robson_enum as varchar
check (value in ('1','2a','2b','3','4a','4b','5.1','5.2',
  '6','7','8','9','10'));
-- Dominio analgesia_enum per parto
create domain analgesia_enum as varchar
check (value in ('spinale','peridurale','spinale_peridurale',
  'calinox'));
-- Dominio sottotipo_parto_enum per parto_con_travaglio
create domain sottotipo_parto_enum as varchar
check (value in ('naturale','operativo','cesareo','naturale_operativo',
  'naturale_cesareo','operativo_cesareo'));
-- Dominio lacerazioni_enum per parto_con_travaglio
create domain lacerazioni_enum as varchar
check (value in ('nessuna','episiotomia','tracheloraffia','grado_1',
  'grado_2','grado_3','grado_4','altro'));
-- Dominio metodo_induzione per induzione
create domain metodo_induzione as varchar
check (value in ('amnioressi','cook','cook_misoprostolo','cook_ossitocina',
  'dilapan','dilapan_misoprostolo','dilapan_ossitocina','misoprostolo',
  'propess','propidil'));
\end{lstlisting}

\FloatBarrier

\section{Definizione delle tabelle}

Definiamo con \emph{script} SQL tutte le tabelle presentate nello schema logico (Sezione \ref{logical}).
Insieme agli attributi vengono introdotti anche tutti i vincoli di chiave esterna e alcuni vincoli aggiuntivi che si applicano ad attributi di un singolo record.
Rimarranno da definire separatamente i vincoli che coinvolgono dati memorizzati su più tabelle o che verificano condizioni su dati aggregati.

Nei vincoli di chiave esterna (\sql{foreign key}) si indica la tabella e l'attributo o la tupla di attributi a cui si fa riferimento (\sql{references}).
Le opzioni \sql{on update cascade} e \sql{on delete cascade} indicano che determinate operazioni alla chiave primaria della tabella puntata dal riferimento vengono riprodotte a cascata sulla tabella dipendente, rispettivamente nei casi di modifiche e di cancellazioni.

\subsection{Area della gravidanza}

La tabella \tab{paziente} (\lstlistingname{} \ref{ptabpaziente}) utilizza il dominio \tab{codice\_fiscale} definito precedentemente.

Nella tabella \tab{gravidanza} (\lstlistingname{} \ref{ptabgravidanza}) è stato introdotto come chiave primaria un attributo \at{id}, da intendersi come numero progressivo; un'implementazione tipica e di \enquote{basso livello} degli identificatori di questo tipo prevede di dichiarare l'attributo come intero e chiave primaria, forzando l'utente a determinare il valore da assegnare a \at{id} ad ogni inserimento, solitamente calcolando il massimo dei valori \at{id} presenti nella tabella e aggiungendo 1.
In PostgreSQL \cite{Pos25} è possibile ovviare a tale ostacolo definendo il campo \at{id} come \sql{serial}: non è più necessario indicare né calcolare manualmente il valore \at{id} da assegnare perché viene determinato all'occorrenza, permettendo alle \emph{query} di inserimento di esserne trasparenti.
Nell'implementazione, \sql{serial} è \emph{zucchero sintattico} che si traduce nella definizione di una \sql{sequence} di \sql{integer} (a cui vengono dedicati 4 byte) ed esistono le varianti \sql{smallserial} (2 byte, corrispondente a \sql{smallint}) e \sql{bigserial} (8 byte, corrispondente a \sql{bigint}).
Quando un valore dichiarato come \sql{serial} viene usato come chiave esterna in altre tabelle deve essere trattato come il tipo \sql{integer} corrispondente.

Nella definizione della tabella \tab{gravidanza} vengono formalizzati i vincoli di unicità da imporre su tuple di attributi, che corrispondono alle chiavi candidate dello schema concettuale, esposti nella Sezione \ref{logicalpregnancy}.
Aggiungendo ulteriori vincoli a \tab{gravidanza} si possono soddisfare l'integrità referenziale verso la tabella \tab{paziente} e il vincolo relativo agli attributi \at{pma\_tipo} e \at{pma\_ovodonazione}, riportati sempre nella Sezione \ref{logicalpregnancy}.
Per il vincolo rimanente, relativo alle proprietà di crescenza dei valori di parità, si definisce un \emph{trigger} apposito (Sezione \ref{triggerspregnancy}).

La tabella \tab{malattia} (\lstlistingname{} \ref{ptabmalattia}) e la tabella \tab{malattia\_gravidanza} (\lstlistingname{} \ref{ptabmalattiagravidanza}) seguono le definizioni riportate nello schema logico.
Sulla seconda vengono imposti i vincoli di integrità referenziale.

\subsection{Area delle visite}
\label{tablesvisits}

La tabella \tab{visita} (\lstlistingname{} \ref{ptabvisita}) utilizza i domini \tab{categoria\_visita\_enum} e \tab{stato\_crescita\_enum} definiti precedentemente; fatta eccezione per il vincolo di chiave esterna i diversi vincoli imposti su questa tabella (Sezione \ref{logicalvisits}) vengono implementati attraverso \emph{trigger} (Sezione \ref{triggersvisits}).

Le tabelle \tab{esame} (\lstlistingname{} \ref{ptabesame}) e \tab{esame\_visita} (\lstlistingname{} \ref{ptabesamevisita}) sono definite come nello schema logico.
Il vincolo imposto sul tipo dell'attributo \at{esito} della tabella \tab{esame\_visita} (Sezione \ref{logicalvisits}) viene riformulato, considerando l'implementazione in SQL, come segue.
\begin{itemize}
\item[\Con{}] Per ogni esame registrato per una data visita, si controlla la corrispondenza tra \at{esito} e il valore di \tab{tipo\_esito} della tabella \tab{esame}. Se il valore è \val{\{numeric\}}\footnote{
  La notazione \val{\{numeric\}} indica un array composto del solo elemento \val{numeric}.
} il valore di \at{esito} deve essere la rappresentazione come stringa di un numero. Se il valore è \val{\{string\}} il valore può essere una stringa arbitraria. Se il valore è diverso da questi, ovvero è un array (di stringhe) di lunghezza arbitraria, i suoi elementi sono da intendersi come i possibili valori di un tipo enumerazione definito appositamente per quell'esame, quindi il valore di \at{esito} deve essere uno dei valori possibili di questo tipo.
\end{itemize}

\subsection{Area del parto}

Nella tabella \tab{parto} (\lstlistingname{} \ref{ptabparto}) utilizziamo molti dei domini di tipo enumerazione definiti nella Sezione \ref{physicaldomains}.
Insieme ad essa definiamo le tabelle \tab{cesareo\_programmato} (\lstlistingname{} \ref{ptabcesareoprogrammato}) e \tab{parto\_con\_travaglio} (\lstlistingname{} \ref{ptabpartocontravaglio}) che contengono i dati delle entità specializzate, come da schema ristrutturato.
Quest'ultima tabella deve soddisfare i vincoli sugli attributi \at{motivo} e \at{kristeller} indicati nella Sezione \ref{logicaldelivery}.
Definiamo inoltre la tabella \tab{induzione} (\lstlistingname \ref{ptabinduzione}).

I due vincoli rimanenti della Sezione \ref{logicaldelivery}, che impongono che ogni record di \tab{parto} deve averne uno e uno solo corrispondente in una delle due tabelle \tab{cesareo\_programmato} e \tab{parto\_con\_travaglio} vengono implementati con \emph{trigger} (Sezione \ref{triggersdelivery}).

\subsection{Area del neonato}

Le tabelle \tab{neonato} (\lstlistingname{} \ref{ptabneonato}), \tab{tracciato} (\lstlistingname{} \ref{ptabtracciato}), \tab{misurazione} (\lstlistingname{} \ref{ptabmisurazione}) e\linebreak \tab{misurazione\_neonato} (\lstlistingname{} \ref{ptabmisurazioneneonato}) seguono le definizioni previste dallo schema logico.
Rimane da implementare un solo vincolo, l'unico della Sezione \ref{logicalnewborn}, che verrà fatto con \emph{trigger} (Sezione \ref{triggersnewborn}).

\FloatBarrier

\begin{lstlisting}[float,caption={Definizione della tabella \tab{paziente}.},label=ptabpaziente]
create table paziente (
  cf codice_fiscale,
  primary key (cf),
  nome varchar not null,
  cognome varchar not null,
  data_nascita date not null
);
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione della tabella \tab{gravidanza}.},label=ptabgravidanza]
create table gravidanza (
  id serial,
  primary key (id),
  paziente_cf codice_fiscale not null,
  data_primo_ingresso date not null,
  unique (paziente_cf, data_primo_ingresso),
  figli_nati_vivi integer not null,
  aborti_avuti integer not null,
  figli_nati_pretermine integer not null,
  figli_nati_a_termine integer not null,
  unique (paziente_cf, figli_nati_vivi, aborti_avuti, figli_nati_pretermine,
    figli_nati_a_termine),
  parita varchar not null,
  eta_concepimento integer,
  esito boolean,
  pma_tipo pma_tipo_enum,
  pma_ovodonazione boolean,
  pregresso_gdm boolean not null,
  pregressa_pih boolean not null,
  pregressa_tireopatia boolean not null,
  pregressa_preeclampsia boolean not null,
  data_prevista_parto date,
  ultima_mestruazione_ecografica date,
  ultima_mestruazione_anamnestica date,
  annotazioni text,
  -- Vincolo di chiave esterna verso paziente
  foreign key (paziente_cf)
    references paziente (cf)
    on update cascade on delete cascade,
  -- Vincolo sugli attributi relativi alla PMA
  check ((pma_tipo is null and pma_ovodonazione is null)
    or (pma_tipo is not null and pma_ovodonazione is not null))
);
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione della tabella \tab{malattia}.},label=ptabmalattia]
create table malattia (
  codice varchar,
  primary key (codice),
  nome varchar not null
);
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione della tabella \tab{malattia\_gravidanza}.},label=ptabmalattiagravidanza]
create table malattia_gravidanza (
  gravidanza_id integer,
  malattia_codice varchar,
  primary key (gravidanza_id, malattia_codice),
  terapia text,
  -- Vincolo di chiave esterna verso gravidanza
  foreign key (gravidanza_id)
    references gravidanza (id)
    on update cascade on delete cascade,
  -- Vincolo di chiave esterna verso malattia
  foreign key (malattia_codice)
    references malattia (codice)
    on update cascade on delete cascade
);
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione della tabella \tab{visita}.},label=ptabvisita]
create table visita (
  gravidanza_id integer,
  data date,
  primary key (gravidanza_id, data),
  epoca_gestazionale integer not null,
  eta integer not null,
  categoria_visita categoria_visita_enum not null,
  pressione_arteriosa_materna integer,
  anomalie_morfologiche_fetali text,
  prescrizione_asa boolean,
  decorso text,
  fuma boolean,
  premorfologica_indicata boolean,
  stato_crescita stato_crescita_enum,
  utpi real,
  altezza real,
  peso real,
  annotazioni text,
  -- Vincolo di chiave esterna verso gravidanza
  foreign key (gravidanza_id)
    references gravidanza (id)
    on update cascade on delete cascade
);
\end{lstlisting}

% controllare
\begin{lstlisting}[float,caption={Definizione della tabella \tab{esame}.},label=ptabesame]
create table esame (
  nome varchar,
  primary key (nome),
  tipo varchar[] not null
);
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione della tabella \tab{esame\_visita}.},label=ptabesamevisita]
create table esame_visita (
  gravidanza_id integer,
  visita_data date,
  esame_nome varchar,
  primary key (gravidanza_id, visita_data, esame_nome),
  esito varchar not null,
  data_esame date not null,
  -- Vincolo di chiave esterna verso visita
  foreign key (gravidanza_id, visita_data)
    references visita (gravidanza_id, data)
    on update cascade on delete cascade,
  -- Vincolo di chiave esterna verso esame
  foreign key (esame_nome)
    references esame (nome)
    on update cascade on delete cascade
);
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione della tabella \tab{parto}.},label=ptabparto]
create table parto (
  gravidanza_id integer,
  primary key (gravidanza_id),
  tipo_parto tipo_parto_enum not null,
  data_parto date not null,
  eta integer not null,
  epoca_gestazionale integer not null,
  istante_secondamento timestamp not null,
  tipo_secondamento tipo_secondamento_enum not null,
  robson robson_enum not null,
  analgesia analgesia_enum,
  perdita_ematica integer,
  annotazioni text,
  -- Vincolo di chiave esterna verso gravidanza
  foreign key (gravidanza_id)
    references gravidanza (id)
    on update cascade on delete cascade
);
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione della tabella \tab{cesareo\_programmato}.},label=ptabcesareoprogrammato]
create table cesareo_programmato (
  gravidanza_id integer,
  primary key (gravidanza_id),
  motivo varchar not null,
  -- Vincolo di chiave esterna verso parto
  foreign key (gravidanza_id)
    references parto (gravidanza_id)
    on update cascade on delete cascade
);
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione della tabella \tab{parto\_con\_travaglio}.},label=ptabpartocontravaglio]
create table parto_con_travaglio (
  gravidanza_id integer,
  primary key (gravidanza_id),
  sottotipo_parto sottotipo_parto_enum not null,
  motivo varchar,
  lacerazioni lacerazioni_enum not null,
  kristeller boolean,
  istante_rottura_membrane timestamp,
  istante_inizio_fase_attiva timestamp,
  istante_dilatazione_completa timestamp,
  istante_inizio_fase_espulsiva timestamp,
  istante_espulsione timestamp,
  -- Vincolo di chiave esterna verso parto
  foreign key (gravidanza_id)
    references parto (gravidanza_id)
    on update cascade on delete cascade,
  -- Vincolo sull'attributo motivo
  check ((sottotipo_parto = 'naturale' and motivo is null)
    or (sottotipo_parto <> 'naturale' and motivo is not null)),
  -- Vincolo sull'attributo kristeller
  check ((sottotipo_parto = 'cesareo' and kristeller is null)
    or (sottotipo_parto <> 'cesareo' and kristeller is not null))
);
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione della tabella \tab{induzione}.},label=ptabinduzione]
create table induzione (
  gravidanza_id integer,
  istante timestamp,
  primary key (gravidanza_id,istante),
  motivo varchar not null,
  metodo metodo_induzione not null,
  bishop integer not null,
  quantita integer not null,
  cicli_eseguiti integer not null,
  completamento real check (completamento >= 0 and completamento <= 1),
  -- Vincolo di chiave esterna verso parto_con_travaglio
  foreign key (gravidanza_id)
    references parto_con_travaglio (gravidanza_id)
    on update cascade on delete cascade
)
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione della tabella \tab{neonato}.},label=ptabneonato]
create table neonato (
  gravidanza_id integer,
  istante_nascita timestamp,
  primary key (gravidanza_id, istante_nascita),
  peso real,
  altezza real,
  sesso char not null check (sesso in ('M','F')),
  circonferenza_cranica real,
  be real,
  ph real,
  tin boolean not null,
  apgar_min_1 integer not null,
  apgar_min_5 integer not null,
  apgar_min_10 integer,
  -- Vincolo di chiave esterna verso parto
  foreign key (gravidanza_id)
    references parto (gravidanza_id)
    on update cascade on delete cascade
);
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione della tabella \tab{tracciato}.},label=ptabtracciato]
create table tracciato (
  gravidanza_id integer,
  primary key (gravidanza_id),
  numero_progressivo varchar not null,
  istante_inizio timestamp not null,
  -- Vincolo di chiave esterna verso parto
  foreign key (gravidanza_id)
    references parto (gravidanza_id)
    on update cascade on delete cascade
);
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione della tabella \tab{misurazione}.},label=ptabmisurazione]
create table misurazione (
  gravidanza_id integer,
  istante timestamp,
  primary key (gravidanza_id, istante),
  valore_fcm integer,
  valore_toco integer,
  -- Vincolo di chiave esterna verso tracciato
  foreign key (gravidanza_id)
    references tracciato (gravidanza_id)
    on update cascade on delete cascade
);
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione della tabella \tab{misurazione\_neonato}.},label=ptabmisurazioneneonato]
create table misurazione_neonato (
  misurazione_istante timestamp,
  gravidanza_id integer,
  neonato_istante_nascita timestamp,
  primary key (misurazione_istante, gravidanza_id, neonato_istante_nascita),
  -- Vincolo di chiave esterna verso misurazione
  foreign key (gravidanza_id, misurazione_istante)
    references misurazione (gravidanza_id, istante)
    on update cascade on delete cascade,
  -- Vincolo di chiave esterna verso neonato
  foreign key (gravidanza_id, neonato_istante_nascita)
    references neonato (gravidanza_id, istante_nascita)
    on update cascade on delete cascade
);
\end{lstlisting}

\FloatBarrier

\section{Definizione dei trigger}
\label{physicaltriggers}

I \emph{trigger} sono istruzioni che il DBMS esegue come effetto collaterale di modifiche alla base di dati \cite{Sil11}.
Essi vengono attivati da eventi, eventualmente con condizioni che ne limitano l'avvio, e chiamano procedure che possono operare sui dati presenti nella tabella prima dell'esecuzione oppure dopo l'esecuzione della \emph{query} che ha scatenato l'evento.

Il funzionamento della base di dati è di tipo transazionale, ovvero permette di svolgere un'insieme di operazioni distinte come se fossero atomiche: ciò permette di eseguire \emph{query}, anche con \emph{trigger} avviati come effetto collaterale, con la garanzia che alla loro conclusione le modifiche saranno permanenti (\emph{commit}) e le invarianti dei vincoli saranno rispettate; nel caso di errori avvenuti all'interno dell'operazione atomica o in seguito a istruzioni specifiche, si effettua un \emph{rollback} che annulla tutte le modifiche parziali e riporta il sistema nello stato precedente, in cui le invarianti valevano ancora.

Per permettere un corretto funzionamento dei \emph{trigger}, ovvero per consentire alle operazioni interne alla transazione di poter violare temporaneamente i vincoli e di rimandare la verifica della loro validità solo alla fine della transazione, è necessario dichiararli utilizzando le parole chiave \sql{deferrable initially deferred} e le transazioni dovranno includere il comando \sql{set constraints all deferred}.

\subsection{Sintesi dei vincoli da implementare con trigger}
\label{physicaltriggerssynthesis}

Elenchiamo di seguito i vincoli esplicitati insieme allo schema logico (Sezione \ref{logical}) che non sono soddisfacibili con le sole definizioni delle tabelle, ovvero che richiedono dei \emph{trigger} appositi per essere verificati.

\begin{enumerate}
\item Se una paziente ha più di una gravidanza, per ogni coppia di gravidanze successive i valori di \at{figli\_nati\_vivi}, \at{aborti\_avuti}, \at{figli\_nati\_pretermine} e \at{figli\_nati\_a\_termine} sono tutti non decrescenti e almeno uno tra essi è crescente (Sezione \ref{logicalpregnancy}).
\item Per ogni gravidanza, in \tab{visita} esiste al massimo un solo record che ha \val{primo\_trimestre} nel campo \at{categoria\_visita} (Sezione \ref{logicalvisits}).
\item Per ogni gravidanza, in \tab{visita} esiste al massimo un solo record che ha \val{secondo\_trimestre} nel campo \at{categoria\_visita} (Sezione \ref{logicalvisits}).
\item Per ogni gravidanza deve essere presente almeno un record in \tab{visita} oppure in \tab{parto} (Sezione \ref{logicalvisits}).
\item Per ogni esame registrato per una data visita, si controlla la corrispondenza tra \at{esito} e il valore di \tab{tipo\_esito} della tabella \tab{esame}. Se il valore è \val{\{numeric\}} il valore di \at{esito} deve essere la rappresentazione come stringa di un numero. Se il valore è \val{\{string\}} il valore può essere una stringa arbitraria. Se il valore è diverso da questi, ovvero è un array (di stringhe) di lunghezza arbitraria, i suoi elementi sono da intendersi come i possibili valori di un tipo enumerazione definito appositamente per quell'esame, quindi il valore di \at{esito} deve essere uno dei valori possibili di questo tipo (Sezione \ref{tablesvisits})
\item Il valore di \at{tipo\_parto} è \val{cesareo\_programmato} se e solo se il parto ha un record corrispondente in \tab{cesareo\_programmato} (Sezione \ref{logicaldelivery}).
\item Il valore di \at{tipo\_parto} è \val{parto\_con\_travaglio} se e solo se il parto ha un record corrispondente in \tab{parto\_con\_travaglio} (Sezione \ref{logicaldelivery}).
\item Per ogni misurazione deve essere presente almeno uno tra l'attributo \at{valore\_fcm}, l'attributo \at{valore\_toco} e un record nella tabella \tab{misurazione\_neonato} (Sezione \ref{logicalnewborn}).
\end{enumerate}

A questi aggiungiamo i diversi attributi derivati, ovvero calcolabili o dipendenti da altre informazioni già presenti nella base di dati e che quindi devono essere gestiti automaticamente in caso di inserimenti o modifiche per evitare inconsistenze.

\begin{enumerate}
\setcounter{enumi}{8}
\item Nella tabella \tab{gravidanza} sono derivati gli attributi \at{data\_primo\_ingresso} e \at{parita}.
\item Nella tabella \tab{visita} è derivato l'attributo \at{eta}.
\item Nella tabella \tab{parto} è derivato l'attributo \at{eta}.
\end{enumerate}

\subsection{Area della gravidanza}
\label{triggerspregnancy}

Il \emph{trigger} \tab{gravidanza\_ordinamento} (\lstlistingname{} \ref{ptrggravidanzaordinamento}) verifica il vincolo 1, ovvero che la tabella \tab{gravidanza}, considerando volta per volta i record relativi a ciascuna paziente, se viene ordinata secondo l'attributo \at{data\_primo\_ingresso} allora essa è ordinata anche secondo ciascuno degli attributi che compongono la parità\footnote{
  Il vincolo di unicità posto sulla tupla composta da \at{paziente\_cf} e i quattro attributi componenti della parità, insieme al vincolo di ordinamento (ovvero non decrescenza) per ciascun attributo numerico, implica che per ogni record almeno un attributo numerico è diverso da record precedente e di conseguenza si ottiene la crescenza stretta per tale attributo.
}.
Ciò viene svolto da un ciclo \sql{for}, costrutto disponibile 

Il \emph{trigger} \tab{gravidanza\_derivati} (\lstlistingname{} \ref{ptrggravidanzaderivati}) soddisfa il vincolo 9, ovvero definisce come si calcolano gli attributi derivati della tabella \tab{gravidanza} per ogni riga inserita o aggiornata.
La parità è calcolata come concatenazione\footnote{
  L'operatore di concatenazione (\sql{||} in SQL) è applicabile solo ad argomenti di tipo testuale, quindi per applicarlo a valori numerici è richiesto un \emph{casting} esplicito.
} dei diversi valori indicati relativi alle gravidanze passate, mentre la data di primo ingresso è la minima nell'insieme delle date delle visite svolte con la data, se presente, del parto.

Il \emph{trigger} \tab{gravidanza\_vincoli} (\lstlistingname{} \ref{ptrggravidanzavincoli}) soddisfa i vincoli 2, 3 e 4, ovvero controlla che non ci siano più di una visita del primo trimestre e più di una del secondo trimestre per ogni gravidanza e che ogni gravidanza abbia almeno una visita o un parto associato.
In generale per causare il \emph{rollback} di una transazione è sufficiente eseguire l'istruzione \sql{return null}.
Per i \sql{constraint trigger} non è possibile perché, essendo di tipo \sql{after}, l'istruzione \sql{return null} non ha nessun effetto concreto, quindi per forzare il \emph{rollback} si deve usare il comando \sql{raise exception}.

\subsection{Area delle visite}
\label{triggersvisits}

La gestione della corrispondenza tra l'esito degli esami e il tipo previsto nella tabella \tab{esame} è gestito dal \emph{trigger} \tab{esame\_esito} (\lstlistingname{} \ref{ptrgesameesito}), che legge i valori presenti in \at{tipo\_esito} e verifica la corrispondenza con il valore \at{esito} di \tab{esame\_visita} e tratta i casi dei valori speciali \val{\{numeric\}} e \val{\{string\}}.

La cancellazione di visite può rendere falsa l'invariante del vincolo 4 che impone la presenza di almeno una visita o di un parto per ogni gravidanza.
Per ovviare a questo problema definiamo il \emph{trigger} \tab{visita\_vincoli} (\lstlistingname{} \ref{ptrgvisitavincoli}).
L'aggiornamento dell'età, imposto dal vincolo 10, è implementato dal \emph{trigger} \tab{visita\_eta} (\lstlistingname{} \ref{ptrgvisitaeta}).

\subsection{Area del parto}
\label{triggersdelivery}

Anche nella tabella \tab{parto} la cancellazione di record può violare il vincolo 4, quindi si definisce un \emph{trigger} \tab{parto\_vincoli} (\lstlistingname{} \ref{ptrgvisitavincoli}) che usa la stessa funzione richiamata dal \emph{trigger} \tab{visita\_vincoli}.

Il \emph{trigger} \tab{parto\_tipo} soddisfa i vincoli 6 e 7, ovvero verifica che a seconda del tipo indicato nell'attributo \at{tipo\_parto} ci sia un record\footnote{
  I vincoli di chiave primaria nelle tabelle \tab{cesareo\_programmato} e \tab{parto\_con\_travaglio} garantiscono l'unicità in ciascuna tabella, quindi è sufficiente verificare la presenza in una e l'assenza nell'altra tabella.
} nella tabella corrispondente.
Una violazione dello stesso vincolo può derivare anche dalla cancellazione di record nelle due tabelle delle sottoentità, quindi è necessario aggiungere due trigger \tab{cesareo\_programmato\_vincoli} e \tab{parto\_con\_travaglio\_vincoli} (\lstlistingname{} \ref{ptrgcesareovincoli}) che fanno riferimento a un unica funzione di verifica.

L'aggiornamento dell'età, imposto dal vincolo 11, è implementato dal \emph{trigger} \tab{parto\_eta} (\lstlistingname{} \ref{ptrgpartoeta}) in modo analogo a \tab{visita\_eta}.

\subsection{Area del neonato}
\label{triggersnewborn}

Il vincolo numero 8, che impone la presenza di almeno un valore per ogni misurazione di un tracciato, è implementato con il \emph{trigger} \tab{misurazione\_vincoli} (\lstlistingname{} \ref{ptrgmisurazionevincoli}) che esegue il controllo ad ogni inserimento in \tab{misurazione}.
Il vincolo può essere violato anche da cancellazioni nella tabella \tab{misurazione\_neonato}, quindi è necessario aggiungere un altro \emph{trigger} (\lstlistingname{} \ref{ptrgmisurazioneneonatovincoli}), che è una minima variazione del precedente.

\FloatBarrier

\begin{lstlisting}[float,caption={Definizione del \emph{trigger} \tab{gravidanza\_ordinamento}.},label=ptrggravidanzaordinamento]
-- Definizione della funzione di aggiornamento
create or replace function gravidanza_controlla_ordinamento()
returns trigger language plpgsql as $$
declare
  rec record;
  is_init boolean := false; -- L'if non si valuta al primo giro
  pre_rec record;
begin
  for rec in
    -- Selezione dei valori di parità per le gravidanze della  stessa paziente
    (select figli_nati_vivi as fnv, aborti_avuti as aa,
    figli_nati_pretermine as fnp, figli_nati_a_termine as fna,
    data_primo_ingresso
    from gravidanza
    where paziente_cf = new.paziente_cf
    order by data_primo_ingresso asc)
  loop
    -- Verifica dell'ordinamento
    if is_init
      and (rec.fnv < pre_rec.fnv
        or rec.aa < pre_rec.aa
        or rec.fnp < pre_rec.fnv
        or rec.fna < pre_rec.fna)
    then
      raise exception 'Almeno un attributo di parità non è ordinato';
    end if;
    is_init := true;
    pre_rec := rec;
  end loop;
end;
$$;
-- Definizione del trigger
create constraint trigger gravidanza_ordinamento
after insert or update on gravidanza
deferrable initially deferred
for each row
execute procedure gravidanza_controlla_ordinamento();
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione del \emph{trigger} \tab{gravidanza\_derivati}.},label=ptrggravidanzaderivati]
-- Definizione della funzione di aggiornamento
create or replace function gravidanza_aggiorna_derivati()
returns trigger language plpgsql as $$
begin
  -- Calcolo dell'attributo parità
  new.parita := cast(new.figli_nati_a_termine as text)
    || cast(new.figli_nati_pretermine as text)
    || cast(new.aborti_avuti as text)
    || cast(new.figli_nati_vivi as text);
  -- Calcolo dell'attributo data_primo_ingresso
  new.data_primo_ingresso :=
    (select min(data) from
      (select data from visita
      where gravidanza_id = new.id
      union
      select data_parto from parto
      where gravidanza_id = new.id));
  return new;
end;
$$;
-- Definizione del trigger
create constraint trigger gravidanza_derivati
after insert or update on gravidanza
deferrable initially deferred
for each row
execute procedure gravidanza_aggiorna_derivati();
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione del \emph{trigger} \tab{gravidanza\_vincoli}.},label=ptrggravidanzavincoli]
-- Definizione della funzione di aggiornamento
create or replace function gravidanza_controlla_vincoli()
returns trigger language plpgsql as $$
begin
  -- Presenza di una visita o di un parto
  if
    not exists (select gravidanza_id from visita
    where gravidanza_id = new.id
    union
    select gravidanza_id from parto
    where gravidanza_id = new.id)
  then
    raise exception 'La gravidanza non ha visite né parto associato';
  end if;
  -- Presenza di non più di una visita del primo trimestre
  if
    ((select count(*) from visita
    where gravidanza_id = new.id
    and categoria_visita = 'primo_trimestre') > 1)
  then
    raise exception 'Più di una visita del primo trimestre';
  end if;
  -- Presenza di non più di una visita del secondo trimestre
  if
    ((select count(*) from visita
    where gravidanza_id = new.id
    and categoria_visita = 'secondo_trimestre') > 1)
  then
    raise exception 'Più di una visita del secondo trimestre';
  end if;
  return new;
end;
$$;
-- Definizione del trigger
create constraint trigger gravidanza_vincoli
after insert or update on gravidanza
deferrable initially deferred
for each row
execute procedure gravidanza_controlla_vincoli();
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione del \emph{trigger} \tab{esame\_esito}.},label=ptrgesameesito]
-- Definizione della funzione di aggiornamento
create or replace function esame_controlla_esito()
returns trigger language plpgsql as $$
declare
  tipo_esito varchar[];
  esito_val varchar;
  numerico boolean := true;
begin
  tipo_esito := (select tipo_esito from esame
    where nome = new.esame_nome);
  -- Corrispondenza del tipo dell'esito
  if (tipo_esito[1] == 'numeric')
  then
    -- Caso numerico
    begin
      esito_val := new.esito::numeric;
    exception when others then
      numerico := false;
    end;
    if numerico
    then return new;
    else raise exception 'Non corrisponde al tipo numerico';
    end if;
  else
  if (tipo_esito[1] == 'string')
  then
    -- Caso stringa generica
    return new;
  else
    -- Caso tipo enum
    if (new.esito = any (tipo_esito))
    then return new;
    else raise exception 'Non corrisponde al tipo enumerazione';
    end if;
  end if;
  end if;
  return new;
end;
$$;
-- Definizione del trigger
create constraint trigger esame_esito
after insert or update on esame_visita
deferrable initially deferred
for each row
execute procedure esame_controlla_esito();
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione dei \emph{trigger} \tab{visita\_vincoli} e \tab{esame\_vincoli}.},label=ptrgvisitavincoli]
-- Definizione della funzione di aggiornamento
create or replace function visita_parto_controlla_vincoli()
returns trigger language plpgsql as $$
begin
  -- Presenza di una visita o di un parto
  if
    not exists (select gravidanza_id from visita
    where gravidanza_id = old.id
    union
    select gravidanza_id from parto
    where gravidanza_id = old.id)
  then
    raise exception 'La gravidanza non ha visite né parto associato';
  end if;
end;
$$;
-- Definizione del trigger per la tabella visita
create constraint trigger visita_vincoli
after delete on visita
deferrable initially deferred
for each row
execute procedure gravidanza_controlla_vincoli();
-- Definizione del trigger per la tabella parto
create constraint trigger parto_vincoli
after delete on parto
deferrable initially deferred
for each row
execute procedure gravidanza_controlla_vincoli();
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione del \emph{trigger} \tab{visita\_eta}.},label=ptrgvisitaeta]
-- Definizione della funzione di aggiornamento
create or replace function visita_calcola_eta()
returns trigger language plpgsql as $$
declare
  data_nascita date;
begin
  data_nascita :=
    (select data_nascita from persona, gravidanza
    where persona.cf = gravidanza.paziente_cf
    and gravidanza.id = new.gravidanza_id);
  new.eta := extract (year from age(new.data,data_nascita));
  return new;
end;
$$;
-- Definizione del trigger
create constraint trigger visita_eta
after insert or update on visita
deferrable initially deferred
for each row
execute procedure visita_calcola_eta();
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione del \emph{trigger} \tab{parto\_tipo}.},label=ptrgpartotipo]
-- Definizione della funzione di aggiornamento
create or replace function parto_controlla_tipo()
returns trigger language plpgsql as $$
begin
  -- Corrispondenza tra tipo_parto e tabelle
  if (new.tipo_parto = 'cesareo_programmato')
  then
    -- Si verifica che sia in cesareo programmato
    -- E non in parto con travaglio
    if
      exists (select count(*) from cesareo_programmato
        where gravidanza_id = new.gravidanza_id)
      and not exists (select count(*) from parto_con_cesareo
        where gravidanza_id = new.gravidanza_id)
    then return new;
    else raise exception 'Non corrisponde a cesareo_programmato';
    end if;
  else
    -- Si verifica che sia in parto con travaglio
    -- E non in cesareo programmato
    if
      exists (select count(*) from parto_con_travaglio
        where gravidanza_id = new.gravidanza_id)
      and not exists (select count(*) from cesareo_programmato
        where gravidanza_id = new.gravidanza_id)
    then return new;
    else raise exception 'Non corrisponde a parto_con_travaglio';
    end if;
  end if;
end;
$$;
-- Definizione del trigger
create constraint trigger parto_tipo
after insert or update on parto
deferrable initially deferred
for each row
execute procedure parto_controlla_tipo();
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione dei \emph{trigger} \tab{cesareo\_programmato\_vincoli} e \tab{parto\_con\_travaglio\_vincoli}.},label=ptrgcesareovincoli]
-- Definizione della funzione di aggiornamento
create or replace function parto_controlla_tipo_2()
returns trigger language plpgsql as $$
begin
  -- Corrispondenza tra tipo_parto e tabelle
  if (old.tipo_parto = 'cesareo_programmato')
  then
    -- Si verifica che sia in cesareo programmato
    -- E non in parto con travaglio
    if
      exists (select count(*) from cesareo_programmato
        where gravidanza_id = old.gravidanza_id)
      and not exists (select count(*) from parto_con_cesareo
        where gravidanza_id = old.gravidanza_id)
    then return old;
    else raise exception 'Non corrisponde a cesareo_programmato';
    end if;
  else
    -- Si verifica che sia in parto con travaglio
    -- E non in cesareo programmato
    if
      exists (select count(*) from parto_con_travaglio
        where gravidanza_id = old.gravidanza_id)
      and not exists (select count(*) from cesareo_programmato
        where gravidanza_id = old.gravidanza_id)
    then return old;
    else raise exception 'Non corrisponde a parto_con_travaglio';
    end if;
  end if;
end;
$$;
-- Definizione del trigger
create constraint trigger cesareo_programmato_vincoli
after delete on cesareo_programmato
deferrable initially deferred
for each row
execute procedure parto_controlla_tipo_2();
-- Definizione del trigger
create constraint trigger parto_con_travaglio_vincoli
after delete on parto_con_travaglio
deferrable initially deferred
for each row
execute procedure parto_controlla_tipo_2();
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione del \emph{trigger} \tab{parto\_eta}.},label=ptrgpartoeta]
-- Definizione della funzione di aggiornamento
create or replace function parto_calcola_eta()
returns trigger language plpgsql as $$
declare
  data_nascita date;
begin
  data_nascita :=
    (select data_nascita from persona, gravidanza
    where persona.cf = gravidanza.paziente_cf
    and gravidanza.id = new.gravidanza_id);
  new.eta := extract (year from age(new.data,data_nascita));
  return new;
end;
$$;
-- Definizione del trigger
create constraint trigger parto_eta
after insert or update on parto
deferrable initially deferred
for each row
execute procedure parto_calcola_eta();
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione del \emph{trigger} \tab{misurazione\_vincoli}.},label=ptrgmisurazionevincoli]
-- Definizione della funzione di aggiornamento
create or replace function misurazione_controlla_vincoli()
returns trigger language plpgsql as $$
begin
  -- Presenza di almeno uno dei valori da misurare
  if
    new.valore_fcm is null
    and new.valore_toco is null
    and not exists (select * from misurazione_neonato
      where gravidanza_id = new.gravidanza_id
      and misurazione_istante = new.istante)
  then
    raise exception 'Nessun valore misurato per questo timestamp';
  end if;
  return new;
end;
$$;
-- Definizione del trigger
create constraint trigger misurazione_vincoli
after insert or update on misurazione
deferrable initially deferred
for each row
execute procedure misurazione_controlla_vincoli();
\end{lstlisting}

\begin{lstlisting}[float,caption={Definizione del \emph{trigger} \tab{misurazione\_neonato\_vincoli}.},label=ptrgmisurazioneneonatovincoli]
-- Definizione della funzione di aggiornamento
create or replace function misurazione_neonato_controlla_vincoli()
returns trigger language plpgsql as $$
begin
  -- Presenza di almeno uno dei valori da misurare
  if
    old.valore_fcm is null
    and old.valore_toco is null
    and not exists (select * from misurazione_neonato
      where gravidanza_id = old.gravidanza_id
      and misurazione_istante = old.istante)
  then
    raise exception 'Nessun valore misurato per questo timestamp';
  end if;
  return old;
end;
$$;
-- Definizione del trigger
create constraint trigger misurazione_neonato_vincoli
after delete on misurazione_neonato
deferrable initially deferred
for each row
execute procedure misurazione_neonato_controlla_vincoli();
\end{lstlisting}